[
["index.html", "Data Science Project Coding Standards Preface", " Data Science Project Coding Standards 09-May-2017 Preface The purpose of this document is to provide recommendations to help you to structure your projects and write your programs in a way that enables collaboration and ensures consistency for Government Data Science work. When working in a scientific environment, one should always strive to make their work as reproducible as possible. This is no different when working with code and data. There are two essential reasons for this: to show evidence of the correctness of your results to enable others to make use of our methods and results We shall provide guidance only for our preferred tools and approaches. However, the most prevalent guidance to be taken from this document is to use your common sense. If your code begins to look a lot like spaghetti and you are thinking “I feel sorry for the poor sap that I hand this over to” then you should go away and make it so that whoever does inherit your code, or play with it or handle it in any way won’t get upset just by reading it. Our recommended methods of working are intended to make it simple to write, maintain, share and collaborate. If you find any errors or would like to pass comments regarding this content then please contact us. For additional information, please refer to the rOpenSci documentation. "],
["r.html", "1 R 1.1 Programming Styles 1.2 Tools 1.3 Documentating Code 1.4 Testing 1.5 Code Coverage 1.6 Code Packaging 1.7 Dependency Management", " 1 R The R programming language is one of our primary tools for deriving understanding from data. The content below provides guidance on what style to use when programming and what tools we use (and recommend) to enable you to make projects more accessible and easier to share or collaborate on. 1.1 Programming Styles Make pretty code. Hadley Wickham’s R Style Guide should form the basis for all generated R code, this itself is based on Google’s R Style Guide. Some important points to note are to try to stick to 80 characters per line (exceptions are made for .Rmd files or similar) and to use 2 spaces, not tabs, for indentation. With regards to naming conventions, some people prefer snake_case where as others prefer camelCase; generally speaking either are fine so long as you and any collaborators are consistent with your code. Some quick notes on what not to do when programming in R: Do not use attach() Do not use 1:length(x) when writing loops - prefer seq_along() Do not use require(), unless you need to Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read. As with styles of punctuation, there are many possible variations. The following guide describes the style that I use (in this book and elsewhere). Good style is important because while your code only has one author, it’ll usually have multiple readers. This is especially true when you’re writing code with others. In that case, it’s a good idea to agree on a common style up-front. Since no style is strictly better than another, working with others may mean that you’ll need to sacrifice some preferred aspects of your style. The formatR package, by Yihui Xie, makes it easier to clean up poorly formatted code. It can’t do everything, but it can quickly get your code from terrible to pretty good. Make sure to read the notes before using it. Notation and naming File names File names should be meaningful and end in .R (yes, uppercase). # Good fit_models.R utility_functions.R # Bad foo.r stuff.r If files need to be run in sequence, prefix them with numbers: 0_download.R 1_parse.R 2_explore.R Pay attention to capitalization, since you, or some of your collaborators, might be using an operating system with a case-insensitive file system (e.g., Microsoft Windows or OS X) which can lead to problems with (case-sensitive) revision control systems. Never use filenames that differ only in capitalisation. Object names “There are only two hard things in Computer Science: cache invalidation and naming things.” — Phil Karlton Variable and function names should be lowercase. Use an underscore (_) to separate words within a name. Generally, variable names should be nouns and function names should be verbs. Strive for names that are concise and meaningful (this is not easy!). Although standard R uses dots extensively in function names (contrib.url()), methods (all.equal), or class names (data.frame), it’s better to use underscores. For example, the basic S3 scheme to define a method for a class, using a generic function, would be to concatenate them with a dot, like this generic.class. This can lead to confusing methods like as.data.frame.data.frame() whereas something like print.my_class() is unambiguous. # Good day_one day_1 # Bad first_day_of_the_month DayOne dayone djm1 Where possible, avoid using names of existing functions and variables. This will cause confusion for the readers of your code. # Bad T &lt;- FALSE c &lt;- 10 mean &lt;- function(x) sum(x) Syntax Spacing Place spaces around all infix operators (=, +, -, &lt;-, etc.). The same rule applies when using = in function calls. Always put a space after a comma, and never before (just like in regular English). There’s a small exception to this rule: :, :: and ::: don’t need spaces around them. Place a space before left parentheses, except in a function call. Extra spacing (i.e., more than one space in a row) is ok if it improves alignment of equal signs or assignments (&lt;-). Do not place spaces around code in parentheses or square brackets (unless there’s a comma, in which case see above). Curly braces An opening curly brace should never go on its own line and should always be followed by a new line. A closing curly brace should always go on its own line, unless it’s followed by else (or a closing parenthesis). Always indent the code inside curly braces. When indenting your code, use two spaces. Never use hard tabs (most editors allow you to replace tabs with a set number of spaces so you can still use the tab key). It’s ok to leave very short statements on the same line: if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;) but try to avoid having more than two statements on one line # BAD if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;); x &lt;- runif(10); x + 10 Pipes If you use the %&gt;% operator from the tidyverse, put each verb on its own line. This makes it simpler to rearrange them later, and makes it harder to overlook a step. It is ok to keep a one-step pipe in one line. # Good iris %&gt;% group_by(Species) %&gt;% summarize_all(mean) %&gt;% ungroup %&gt;% gather(measure, value, -Species) %&gt;% arrange(value) iris %&gt;% arrange(Petal.Width) # Bad iris %&gt;% group_by(Species) %&gt;% summarize_all(mean) %&gt;% ungroup %&gt;% gather(measure, value, -Species) %&gt;% arrange(value) Line length Strive to limit your code to 80 characters per line. This fits comfortably on a printed page with a reasonably sized font. If you find yourself running out of room, this is a good indication that you should encapsulate some of the work in a separate function. Assignment Use &lt;-, not =, for assignment. # Good x &lt;- 5 # Bad x = 5 Quotes Use &quot;, not ', for quoting text. The only exception is when the text already contains double quotes and no single quotes. Functions Should be verbs, where possible. Only use return() for early returns. Strive to keep blocks within a function on one screen, so around 20-30 lines maximum. Some even argue that if a function has 20 lines it should be split into smaller functions but we do not mandate this. Commenting guidelines Comment your code. Each line of a comment should begin with the comment (‘pound’) symbol, # and a single space: #. Comments should explain the why, not the what. Use commented lines of - and = to break up your file into easily readable chunks. # Load data --------------------------- df &lt;- read.csv(&#39;foo.csv&#39;) # Plot data --------------------------- ggplot(df, aes(x=foo, y=bar)) + geom_line() 1.2 Tools The lintr package is designed to help you stick to certain coding conventions. lintr can be executed as standalone or as part of build. Using lintr will ensure we are all conforming to the same coding standards. Additionally, lintr can be ran as part of your testthat tests and integrates well with RStudio and external editors such as Emacs (with flycheck). Quick formatting to code can be applied using the formatR package. The formatR package was designed to reformat R code to improve readability; the main workhorse is the function tidy_source(). Features include: long lines of code and comments are reorganized into appropriately shorter ones spaces and indent are added where necessary the number of spaces to indent the code (i.e. tab width) can be specified an else statement in a separate line without the leading } will be moved one line back = as an assignment operator can be replaced with &lt;- Note that not all aspects of this may match the guidance we have provided above but it can at least begin to help you to refactor your code to be more accessible. The goodpractice is useful for giving advice about good practices when building R packages. Advice includes functions and syntax to avoid, package structure, code complexity, code formatting (using lintr) and more. 1.3 Documentating Code Documenting our code is an essential part of what we do. We should document our code to the point where someone else can view it and understand how it works and why. Documentation is also useful for future-you (so you remember what your functions were supposed to do), and for developers extending your code. When documenting functions in R, it is standard practice to use the Roxygen2 package which not only helps to generate your manual (.Rd) files, but also manages your NAMESPACE file and the Collate field of the DESCRIPTION file. This integrates really nicely with R package building. For more information on Roxygen2, see the Manual section of the R packages book and the vignettes on the CRAN package page. 1.4 Testing In functional programming, code is designed to be reused again and again with different inputs, making for simpler code that is easier to understand and audit. Writing functions allows us to more easily document our code meaning that others can use it without too much hassle. It also means that we can build tests to ensure the code continues to work as expected when we make changes to it. Everytime you write a new function, you should strive to write tests for that function. In fact, some people use a test driven development approach whereby tests are written first and a function is written second to pass those tests. In the case a bug is discovered with a function, a test should always be written to ensure that bug is not reintroduced at some point in the future - you are essentially protecting yourself from future you’s mistakes. There are different packages that help with writing and running tests in R such as RUnit and testthat. It is the latter that is generally recommended. More information about testthat can be found in the R packages book. 1.5 Code Coverage Writing tests for our code we can ensure that it works as expected and check when changes to that code break pre-existing functionality. But how do we know whether we have tested each possible scenario for our functions? How do we know which lines of code are ran during our tests? This is where code coverage comes in. Code coverage is a measure of the amount of code being exercised by a set of tests. It is an indirect measure of test quality and completeness. For example, in the code below, we can see that lines 112-115 and 117-120 are not explicitly tested. In this case, we probably don’t need to worry very much, but on other occasions this might prompt us to write more tests. Figure 1.1: Code Coverage Measuring code coverage allows developers to asses their progress in quality checking their own (or their collaborators) code. Measuring code coverage allows code consumers to have confidence in the measures taken by the package authors to verify high code quality. – Jim Hester 1.5.0.1 Coverage Services In R we can obtain this functionality by using covr. This allows the user to track and report code coverage for your package and (optionally) upload the results to a coverage service like Codecov or Coveralls. covr works with both RUnit and testthat, though we are using testthat for our tests. covr provides three functions to calculate test coverage: package_coverage() performs coverage calculation on an R package (unit tests must be contained in the “tests” directory) file_coverage() performs coverage calculation on one or more R scripts by executing one or more R scripts. function_coverage() performs coverage calculation on a single named function, using an expression provided Please read the documentation for more information on how covr works. 1.6 Code Packaging When writing code for a project, that code should ideally be held within a self contained package or series of packages. This helps to manage dependencies on other packages, code testing, documentation and more. For R, there is one major resource that you should make yourself familiar with: http://r-pkgs.had.co.nz/. This book should cover all the essentials you will need to know in order to write an R package. Once you have mastered this book, you may wish to consider the Writing R Extensions manual, though this is a heavy read. When writing R packages, you should continually check the results of your R CMD check and remove any NOTEs, WARNINGs and ERRORs, where possible. We should not ship broken code! 1.7 Dependency Management Dependency management systems are incredibly important, particularly in the world of analysis. Whenever we produce some code to perform statistical analysis or machine learning, we need to be able to recreate those results exactly. This could be the day after or the year after and we need to know which versions of which packages we must have installed on our machine. Updates to packages can produce breaking changes and our code may produce slightly different results, or worse yet, not run at all. Then installing a specific packages for a certain project may make code on other projects break. That results can change so much with different pkg versions is scary (and ignored by many) https://t.co/wn5x3UBgQz #rstats #reproducibility pic.twitter.com/Jp4ASOKC81 — F Rodriguez-Sanchez (@frod_san) 29 March 2017 Moreover, you may be presented with someone else’s code but without them explicitly stating which packages you need, it is not always obvious, and even then you still have the manual challenge of installing the correct versions of each package yourself. These packages may then end up being globally installed when you don’t need them for any other project, therefore clogging up your system. Whilst we would recommend docker for project management it is not always the best choice. Whilst keeping track of dependencies in R can be a chore, particularly when using lots of different packages such as those belonging to the tidyverse there are different packages which aim to help with this. 1.7.0.1 DESCRIPTION file This is the most basic way of maintanining dependencies in R, though it is not recommended - it is only part of the dependency management system you should employ. Each R package will have a DESCRIPTION file which should contain a list of packages your package Depends on, Imports and Suggests. You can specify certain versions within for each of these. 1.7.0.2 NAMESPACE file Dependencies in R packages are maintained using the NAMESPACE file. You should never write these files by hand as they are tedious to maintain and this approach is prone to error. Instead, you should consider using the Roxygen2 package which is detailed in the Code Documentation section of this report. 1.7.0.3 The packrat library packrat is a dependency management system for R. Use packrat to make your R projects more: Isolated: Installing a new or updated package for one project won’t break your other projects, and vice versa. That’s because packrat gives each project its own private package library. Portable: Easily transport your projects from one computer to another, even across different platforms. packrat makes it easy to install the packages your project depends on. Reproducible: packrat records the exact package versions you depend on, and ensures those exact versions are the ones that get installed wherever you go. See the project page for more information. 1.7.0.4 The pkgsnap library pkgsnap is a more lightweight alternative to packrat which allows you to backup and restore certain CRAN package versions. pkgsnap will create a snapshot of your installed CRAN packages with snap(), and then use restore() on another system to recreate exactly the same environment. Unfortunately pkgsnap isn’t heavily developed. "],
["python.html", "2 Python 2.1 Style guide 2.2 Package Management", " 2 Python The below are the most immediate features that your code should have. The recommendations in Effective Python give a more in-depth idea of how to write good python code and align with our recommendations. 2.1 Style guide The following sections outline conditions on python code produced for sharing. Spacing Tabs are illegal. All indentation should be in spaces and each level of indent should be either 2 or 4 spaces, but constant throughout the project at either 2 or 4. import numpy as np # Good def main(): &quot;&quot;&quot; This is my docstring There are many others like it But this one is mine &quot;&quot;&quot; def third_eye(n): return 3 * np.eye(n) # Bad def main(): &quot;&quot;&quot; This is my docstring There are many others like it But this one is mine &quot;&quot;&quot; def third_eye(n): return 3 * np.eye(n) Line length No lines should exceed 80 characters. If you find yourself running out of room on a line then it might be a good sign that you need to write a function. Blank lines 1 line: There should be one line between blocks of code, the exceptions are where two lines are recommended. 2 lines: Start and end of function definitions, import blocks, headers, and class definitions should have 2 lines clearning them. # Good import os class Goober(object): &quot;&quot;&quot;| docstrings are good docstrings are great &quot;&quot;&quot; def __init__(self): pass def main(): pass # Bad import os class Goober(object): &quot;&quot;&quot;| docstrings are good docstrings are great &quot;&quot;&quot; def __init__(self): pass def main(): pass Data declarations Elements must align, either in leading or following comma notation. Some examples: list_1 = [ elem_1, elem_2, elem_3 ] list_2 = [ elem_1 , elem_2 , elem_3 ] List comprehensions There should be no more than 2 statements included in any list comprehension. If the comprehension is exceeding this length then break it out into a loop or multiple statements. It might make sense to you now but when somebody else comes to read it they will hate you if you don’t. Exceptions Do not raise base exceptions. Create your own classes which extend them and manage your errors in a meaningful way. Imports Imports should be grouped, at the top of your file and placed in the following order. standard library imports related third party imports local application/library specific imports Put a blank line between each group of imports and include a comment to show the group. The imports in each group should be sorted alphabetically, by module name. Try to avoid from foo import * unless you can be absolutely certain that there are no clashes in the namespace. It may be more suitable to give your module a short alias, such as import pandas as pd. Type hinting Where possible use type hinting as perPEP484. It will make your code more verbose as well as easier to debug and handle. 2.2 Package Management Programs should be packages using one of two methods. First is the python solution virtualenv which allows you to bundle a python executable and all of the needed packages with your program or through the use of docker which facilitates a wider use case and means you do not need to handle exceptions caused by windows and linux libraries and executables not being available on the system. 2.2.1 Choosing a container What virtualenv does is simple, it copies your system python installation and supporting packages to the project root directory and then updates the python paths (when you run activate.sh) to point to this version. You are then free to pip install to your heart’s content without making global changes. Whilst this allows you to localise your python packages it does not incorporate outside dependencies. If you need a running LAMP server, redis, spark or some other external tool you need to add them into your project. You essentially end up polluting your environment with project-specific dependencies. This is not optimal for large projects with database back ends or heavier dependencies and docker should be used. Docker allows you to run a virtual machine in a single thread. This allows you to pre-bundle all of the requirements you have into a single image which can be activated and allow all dependencies to be mimicked on a larger system scale. It leads to a fewer dependency spaghetti issues because you can also use system software management tools such as brew to install things into your images. Docker is also suitable in the use case where virtualenv is a good choice. As such docker is the recommended solution for packaging up python projects. However, it is still quite a young tool and there may be a few kinks that have you falling back on your old, faithful virtualenv. Use your judgement as to which is best in your given situation and easiest to share. Docker is preferred but is not required. "],
["other-languages.html", "3 Other Languages 3.1 Haskell 3.2 Java", " 3 Other Languages 3.1 Haskell For Haskell we recommend Johan Tibell’s style guide. This style guide is similar to the designs we choose for implementing python code and is a good fit for projects. Projects are managed using cabal as the main preference. However, stack is also suitable. So long as the project can be passed on and compiles then whichever tool you use to sandbox your work is fine. It is recommended that you keep your GHC up to date and document which version your program is to be compiled with. Key points from the above style guide are included below. Line Length Maximum line length is 80 characters. Indentation Tabs are illegal. Use spaces for indenting. Indent your code blocks with 4 spaces. Indent the where keyword two spaces to set it apart from the rest of the code and indent the definitions in a where clause 2 spaces. Pragmas Put pragmas immediately following the function they apply to. Example: id :: a -&gt; a id x = x {-# INLINE id #-} In the case of data type definitions you must put the pragma before the type it applies to. Example: data Array e = Array {-# UNPACK #-} !Int !ByteArray Export Lists Format export lists as follows: module Data.Set ( -- * The @Set@ type Set , empty , singleton -- * Querying , member ) where If-then-else clauses Generally, guards and pattern matches should be preferred over if-then-else clauses, where possible. Short cases should usually be put on a single line (when line length allows it). When writing non-monadic code (i.e. when not using do) and guards and pattern matches can’t be used, you can align if-then-else clauses like you would normal expressions: foo = if ... then ... else ... Otherwise, you should be consistent with the 4-spaces indent rule, and the then and the else keyword should be aligned. Examples: foo = do someCode if condition then someMoreCode else someAlternativeCode foo = bar $ \\qux -&gt; if predicate qux then doSomethingSilly else someOtherCode The same rule applies to nested do blocks: foo = do instruction &lt;- decodeInstruction skip &lt;- load Memory.skip if skip == 0x0000 then do execute instruction addCycles $ instructionCycles instruction else do store Memory.skip 0x0000 addCycles 1 Case expressions A case expression can be indented using the two following style: foobar = case something of Just j -&gt; foo Nothing -&gt; bar Align the -&gt; arrows when it helps readability. Imports Imports should be grouped in the following order: standard library imports related third party imports local application/library specific imports Put a blank line between each group of imports. The imports in each group should be sorted alphabetically, by module name. Always use explicit import lists or qualified imports for standard and third party libraries. This makes the code more robust against changes in these libraries. Exception: The Prelude. Comments Punctuation Write proper sentences; start with a capital letter and use proper punctuation. Top-Level Definitions Comment every top level function (particularly exported functions), and provide a type signature; use Haddock syntax in the comments. Comment every exported data type. Function example: -- | Send a message on a socket. The socket must be in a connected -- state. Returns the number of bytes sent. Applications are -- responsible for ensuring that all data has been sent. send :: Socket -- ^ Connected socket -&gt; ByteString -- ^ Data to send -&gt; IO Int -- ^ Bytes sent For functions the documentation should give enough information to apply the function without looking at the function’s definition. Record example: -- | Bla bla bla. data Person = Person { age :: !Int -- ^ Age , name :: !String -- ^ First name } For fields that require longer comments format them like so: data Record = Record { -- | This is a very very very long comment that is split over -- multiple lines. field1 :: !Text -- | This is a second very very very long comment that is split -- over multiple lines. , field2 :: !Int } End-of-Line Comments Separate end-of-line comments from the code using 2 spaces. Align comments for data type definitions. Some examples: data Parser = Parser !Int -- Current position !ByteString -- Remaining input foo :: Int -&gt; Int foo n = salt * 32 + 9 where salt = 453645243 -- Magic hash salt. Links Use in-line links economically. You are encouraged to add links for API names. It is not necessary to add links for all API names in a Haddock comment. We therefore recommend adding a link to an API name if: The user might actually want to click on it for more information (in your judgment), and Only for the first occurrence of each API name in the comment (don’t bother repeating a link) Naming Use camel case (e.g. functionName) when naming functions and upper camel case (e.g. DataType) when naming data types. For readability reasons, don’t capitalize all letters when using an abbreviation. For example, write HttpServer instead of HTTPServer. Exception: Two letter abbreviations, e.g. IO. Modules Use singular when naming modules e.g. use Data.Map and Data.ByteString.Internal instead of Data.Maps and Data.ByteString.Internals. Point-free style Avoid over-using point-free style. For example, this is hard to read: -- Bad: f = (g .) . h Warnings Code should be compilable with -Wall -Werror. There should be no warnings. Exception handling The safe-exceptions library should be used. The library contains guidance on its use. 3.2 Java TODO "],
["version-control.html", "4 Version Control 4.1 Git style guide 4.2 References", " 4 Version Control Few software engineering projects will begin without some form of version control and data science should be no different. Version control software allows us to track the three Ws: Who made Which change, and Why? There are various different version control tools such as Git, SVN and Mercurial. Git is a distributed version control system. It can be used locally on a single machine, on many networked machines or connected to many online repository services such as GitHub, GitLab and BitBucket. Each of these services provides hosting for remote clones of your repository, and makes the code open and easy to share with the world, or if necessary, private and shared with your team only. Government have several GitHub organisation accounts including the Data Science Campus, Office for National Statistics and a more general UK Government account which allow us to use private repositories; please speak to another member of staff about getting help in joining the organisation. 4.1 Git style guide Following a few stylistic guidelines makes it easier for your collaborators to understand the history of changes to the repository. Please try to adopt them or be ready to justify why you chose a different approach. Sticking to these standards will make it much easier to work with others. For example, if two people have changed the same file in the same place, it’ll be easier to resolve conflicts if the commits are small and it’s clear why each change was made and project newcomers can more easily understand the history by reading the commit logs. More importantly, if you can figure out exactly when a bug was introduced, you can easily understand what you were doing (and why!). Some really good advice is: You might think that because no one else will ever look at your repo, that writing good commit messages is not worth the effort. But keep in mind that you have one very important collaborator: future-you! If you spend a little time now polishing your commit messages, future-you will thank you if and when they need to do a post-mortem on a bug. – Hadley Wickham 4.1.1 Repository names All repository names should follow the kebab-case naming convention and be in lower case. 4.1.2 Commit best practices Ideally, each commit should be minimal but complete. They should aim to solve a single specific problem with your code. This makes commits that you make much easier to understand but it also makes it easier to undo commits should you make an error. 4.1.3 Commit frequency You should commit very often. Leaving all changes to be committed at the end of the day is a bad idea as rather than being able to undo a single issue, you may lose an entire day’s work to solve your problem. When you think you have solved a bug, it is always a good idea to include a test to confirm you are correct. Figure 4.1: Try to keep git commit messages as informative as possible When you want to merge your branch to a public one, it’s a good practice to review your commit messages and reword those that are not clear enough, re-order those that need more clarity and squash those commits that should be one. Make use of git rebase --interactive, remember it allows you to, among other things, reword, re-order and squash commits. 4.1.4 Commit message A good commit message briefly summarises the what for scanning purposes, but the important part is that it includes the why you’ve introduced the change. If the what in the message isn’t enough, the diff is there as a fallback, however, this isn’t true for the why. Each commit message consists of a header, a body and a footer. The header has a special format that includes a type and a subject: &lt;type&gt;: &lt;subject&gt; &lt;BLANK LINE&gt; &lt;body&gt; &lt;BLANK LINE&gt; &lt;footer&gt; The first line: type and subject are mandatory, whereas body and footer are optional. Note that the BLANK LINES are mandatory if body or footer are present. Any line of the commit message cannot be longer than 80 characters! This allows the message to be easier to read on github as well as in various git tools. 4.1.4.1 type Must be one of the following: feat: A new feature fix: A bug fix doc: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug or adds a feature perf: A code change that improves performance test: Adding missing tests chore: Changes to the build process or auxiliary tools and libraries such as documentation generation Do not capitalise the first letter. 4.1.4.2 subject The subject contains succinct description of the change: use the imperative, present tense: “Change” not “Changed” nor “Changes” do capitalise first letter no dot (.) at the end 4.1.4.3 body Just as in the subject, use the imperative, present tense: “change” not “changed” nor “changes” The body should include the motivation for the change and contrast this with previous behavior. 4.1.4.4 footer The footer should contain any information about Breaking Changes and is also the place to reference GitHub issues that this commit Closes. Breaking Changes are detected as such if the footer contains a line starting with BREAKING CHANGE: (with optional newlines) The rest of the commit message is then used for this. This commit message structure was mostly taken from here. 4.1.5 Tag names We will follow the SemVer versioning convention: Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, and PATCH version when you make backwards-compatible bug fixes. Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. 4.1.6 Branch size Branches (other than master and development) must be short and as much as possible they should have a single purpose. 4.1.7 Branch names The name of the branch should refer to its purpose. Specify one of the following types: feat fix … (to be expanded) This should then be followed by either a clear reason for the branch or, if the branch refers to an issue, mention the issue number on the name, e.g. bug-52. Do not include your name on the branch name (that’s already recored by Git). All branch names should follow the kebab-case naming convention and be all in lower case. 4.1.8 Workflow practices Before merging your feature branch to a public branch (e.g. master) always rebase your code to the latest version of the public branch and solve the conflicts locally. merge must be --no-fastforward as this with the previous guideline improve readability. Remove the remote feature branch after merging (e.g. git push origin :feature). Keep any destructive actions local. The most common destructive actions are: merge and rebase. 4.2 References https://github.com/alphagov/styleguides/blob/master/git.md https://github.com/conventional-changelog/conventional-changelog/blob/a5505865ff3dd710cf757f50530e73ef0ca641da/conventions/angular.md https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message https://github.com/torvalds/linux/pull/17#issuecomment-5659933 http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html http://semver.org https://git-scm.com/book/ch5-2.html https://dev.to/rpalo/plan-your-commits "],
["packaging-projects.html", "5 Packaging projects", " 5 Packaging projects TODO {-} We say use docker. Its pretty good. "],
["resources.html", "6 Resources 6.1 Setting up your Mac or Linux Machines 6.2 Online Learning Materials", " 6 Resources 6.1 Setting up your Mac or Linux Machines Data Scientists typically use a common set of tools. A script has been prepared which will set up a MacOS or Linux machine with the following set of common tools: R, RStudio and the following R packages: tidyverse, rmarkdown, shiny, mlr Python 3 and the following Python packages: pandas, seaborn, bokeh, numpy, scipy, statsmodels, scikit-learn, virtualenv, jedi LaTeX Slack This script is held within the brew-ds repository on GitHub; instructions can be found in the README.md. 6.2 Online Learning Materials 6.2.0.1 Python codeacademy DataCamp 6.2.0.2 R Coursera tryR DataCamp 6.2.0.3 Docker Docker for beginners hackr.io 6.2.0.4 Documentation Markdown Rmarkdown Bookdown Org mode 6.2.0.5 Version Control try git git tutorial "]
]
